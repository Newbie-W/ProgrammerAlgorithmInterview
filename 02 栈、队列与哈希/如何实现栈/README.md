### 情境：

> - 实现一个栈的数据结构，使其具有以下方法：压栈、弹栈、取栈顶元素、判断栈是否为空以及获取栈中元素个数。<br>

### 方法
- **法一：数组实现**<br>
在采用数组来实现栈时，主要面临的问题是给数组申请多大的存储空间比较合适。（下面这段话，简单概括本书的办法，为，设定一个合适的初始值，如果后期空间不够，则再扩大）<br>
因为在使用栈的时候并不确定以后栈中要存放的数据元素的个数，申请多了会造成空间浪费，而申请少了会导致不够用。本书为了便于理解，采用的方法是给定一个初始的值（假如是10），那么就先申请能存储10个元素大小的数组作为栈的存储空间。在后期使用的过程中，如果空间不够用，再扩大这个空间。<br>
实现思路 如下图2.1.1所示。<br>
![img2.1.1 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.01/img%202.1.1.png)<br>
从上图可知，可以把**数组的首地址**当作**栈底**，同时**记录栈中元素的个数size**，则根据栈底指针和size即可计算出栈顶的地址。<br>
假设数组首地址为Arr，从上图可以看出，**压栈操作其实是把待压栈元素放到数组Arr[size]中，然后执行size++操作**；同理，**弹栈操作其实是取数组Arr[size-1]元素，然后执行size--操作**。<br>

- **法二：链表实现**<br>
在创建链表时，经常使用一种从头结点插入新结点的方法（**头插法**）。最好使用带头结点的链表，这样可以保证对每个结点的操作都是相同的。<br>
实现思路 如下图2.1.2所示。（**步骤个人总结，链表法 直接在头结点后插入或删除元素即可**）<br>
![img2.1.2 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.01/img%202.1.2.png)<br>
在上图中，在进行**压栈**操作的时候，首先需要创建新的结点，把待压栈的元素放到新的结点的数据域中，然后只需要（1）、（2）两步即可实现压栈操作（把新结点加到链表首部）<br>
同理，**弹栈**时，只需要进行（3）的操作就可以删除链表的第一个元素，从而实现弹栈操作（被删除结点所占的存储空间需要被释放）<br>

- **两者比较**
1. 数组实现栈：<br>
优：一个元素值占用一个存储空间<br>
缺：初始化的存储空间问题（上文已经提到，初始存储空间过大过小的问题），过大空间浪费，过小则需要经常扩充，耗时<br>
2. 链表实现栈：<br>
优：使用灵活，仅在需要时申请存储空间<br>
缺：除了存储元素，还要存储指针信息<br>
 