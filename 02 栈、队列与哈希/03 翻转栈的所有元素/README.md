### 情境：

> - 翻转（也叫颠倒）栈的所有元素，例如输入栈{1, 2, 3, 4, 5}，其中，1处在栈顶，翻转之后的栈为{5, 4, 3, 2, 1}，其中，5在栈顶。
> - 实现reverse_stack(s)函数，可在原来基础上添更多函数。
> - 为简化代码，重点放在栈翻转的逻辑上，故使用C++实现，可用C++类库提供的栈。

```C++
#include <iostream>
#include <stack>
using namespace std;

void reverse_stack(stacl<int>& s);
/*更多函数及实现等可添至此处*/

int main() {
	stack<int> s;
	s.push(5);
	s.push(4);
	s.push(3);
	s.push(2);
	s.push(1);
	reverse_stack(s);
	cout<<"翻转后出栈顺序为：";
	while (!s.empty()) {
		cout<<s.top()<<" ";
		s.pop();
	}
	return 0;
}+
```

### 方法
> 1. （**法一**）最容易想到的办法：（借助一个队列，翻转栈的元素；详细说为，）申请一个额外的队列，先把栈中元素依次出栈放到队列里，然后把队列里的元素按照队列顺序入栈，即可实现栈的翻转。
> 这种方法的缺点是，需要申请额外的空间存储队列，空间复杂度高。<br>
> 
> 2. （**法二**）下面的方法为，一种空间复杂度较低的递归的方法<br>
> > **分析**：<br>
> > 递归程序的两个关键因素：递归定义和递归终止条件。本题中，<br>
> > **递归定义**：将当前栈的最底元素移到栈顶，其他元素顺次下移一位，然后对不包含栈顶元素的子栈执行同样的操作；<br>
> > **终止条件**：递归下去，直到栈为空<br>
> > 1. 总体递归流程如图2.3.1所示，进行翻转的操作是：（1）首先，把栈底元素移动到栈顶；（2）然后，对不包含栈顶元素的子栈进行递归调用（对子栈元素进行翻转）<br>
> > ![img2.3.1 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.03/img%202.3.1.PNG)<br>
> > 2. 此外，由于栈的后进先出的特点，使得只能取栈顶元素，因此要把栈底的元素移动到栈顶也需要递归调用才能完成。<br>
> > 主要思路是，把不包含该栈顶元素的子栈的栈底元素移动到子栈的栈顶，然后把栈顶元素与子栈的栈顶元素（其实就是与栈顶相邻的元素）进行交换。为了更容易理解递归调用，可以认为在进行递归调用的时候，子栈已经把栈底元素移动到了栈顶<br>
> > ![img2.3.2 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.03/img%202.3.2.PNG)<br>
> > 
> > **思路步骤**：（:question:）<br>
> > （1）先将栈底元素移至栈顶（递归实现）<br>
> > （2）由于每回移动的是当前栈的栈底元素，不是全部移动，所以需要递归，每次移动一个子栈的栈底元素到栈顶（递归实现一层层子栈）<br>

---
### 方法自总结
> 总体来说，需要两次递归：一次递归到子栈；一次递归，对当前的子栈，交换栈底元素和不包含栈底元素的子栈（即，将栈底元素移至栈顶）

---
### 引申

> 如何给栈排序
> > **方法**  
> > 很容易通过对上述方法进行修改得到栈的排序算法。主要思路是：首先对不包含栈顶元素的子栈进行排序，如果栈顶元素大于子栈的栈顶元素，则交换这两个元素。因此在原题目（栈翻转）实现的方法中，只需要在交换栈顶元素与子栈顶元素的时候增加一个条件判断即可