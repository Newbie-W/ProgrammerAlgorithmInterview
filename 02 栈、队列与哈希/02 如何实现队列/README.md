### 情境：

> - 实现一个队列的数据结构， 使其具有【入队列】、【出队列】、【查看队列首尾元素】以及【查看队列大小】等功能<br>

### 方法
- **法一：数组实现**<br>
如图，给出了一种最简单的实现方式（为了简化实现，代码定义的队列最大空间为10），<br>
> 用```front```来记录**队列首元素的位置**，用```rear```来记录队**列尾元素往后一个位置**。**入队列**时，只需要将待入队列的元素放到数组下标为```rear```的位置，同时执行```rear++```；**出队列**的时候只需要执行```front++```即可
实现思路 如下图2.2.1所示。<br>
![img2.2.1 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.02/img%202.2.1.PNG)<br>
从上图可知，可以把**数组的首地址**当作**栈底**，同时**记录栈中元素的个数size**，则根据栈底指针和size即可计算出栈顶的地址。<br>
假设数组首地址为Arr，从上图可以看出，**压栈操作其实是把待压栈元素放到数组Arr[size]中，然后执行size++操作**；同理，**弹栈操作其实是取数组Arr[size-1]元素，然后执行size--操作**。<br>

- **法二：链表实现**<br>
分别用两个指针指向队列的首元素和尾元素。pHead指向队列首元素。pEnd指向队列尾元素<br>
实现思路 如下图2.2.2所示。（**步骤个人总结，链表法 直接在头结点后插入或删除元素即可**）<br>
![img2.2.2 图](https://github.com/Newbie-W/ProgrammerAlgorithmInterview/blob/master/pics/2.02/img%202.2.2.PNG)<br>
在上图中，**入队列**只需要（1）、（2）两步即可，（把新结点加到链表尾部，然后修改pEnd的指针）<br>
**出队列**时，只需（3），改变pHead的指针，使其指向pHead->next（注：被删除结点所占的存储空间需要被释放）<br>
注：出入队列需注意队列为空的处理操作<br>

- **两者比较及补充**
1. **数组实现栈**：<br>
最大的缺点：出队列后数组前半部分空间不能充分利用<br>
上述缺点的解决方法：把数组看成环状空间（循环队列）。当数组最后一个位置被占用后，可以从数组首位置开始循环利用<br>
2. **链表实现栈**：<br>
优：用链表实现队列更为灵活<br>
缺：与数组实现方法相比，它多了用来存储结点关系的指针空间。<br>
此外也可以用循环链表来实现队列，这样只需要一个指向链表最后一个元素的指针即可。（因为通过指向链表尾元素非常容易找到链表的首结点）<br>
3. 这两种方法压栈与弹栈的时间复杂度都为O(1)<br>

---
自总结
注意：
1.
数组情况设定时，两个指针，分别记录**队首元素位置**和**队尾元素后的一个位置**
而链表实现中，两个指针，分别指向**队首元素**和**队尾元素**，（从而队列中最后一个元素出队列后，还需要更改队尾指针；空队列中新元素入队列时，队首指针也需要进行更改）
 